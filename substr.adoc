= `std::string::substr() &&`
:nofooter:
:!webfonts:
:sectnums: // numbered headings
:source-highlighter: pygments

|===
|Document number: | PxxxxR0
|Date:            | 2021-09-07
|Project:         | Programming Language C++, Library Working Group
|Reply-to:        | federico.kircheis@gmail.com
|===

// http://open-std.org/jtc1/sc22/wg21/docs/papers/2021/n4892.pdf

== Motivation


[cols="3"]
|===
| | without this proposal | with this proposal
a|
[source, cpp]
----
auto a = std::string(/* */);
auto b = a.substr(/*  */);
----
| Value of `a` does not change | Value of `a` does not change

a|
[source, cpp]
----
auto foo() -> std::string;

auto b = foo.substr(/* */);
----
| `foo()` returns a temporary `std::string`. `.substr` creates a new string and copies the relevant content. At last the temporary string returned by foo is released.
| `foo()` returns a `std::string`, `.substr` implementation can reuse the storage of the string returned by foo and leave it in a valid but unspecified state. The temporary string returned by `foo()` is released.

The different behavior cannot be observed in {cpp}.


a|
[source, cpp]
----
auto a = std::string(/* */).substr(/* */);
----
| A temporary `std::string` is created, on that instance `.substr` creates a new string and copies the relevant content. At last the temporary string is released.
| A temporary `std::string` is created, on that instance `.substr` implementation can reuse the storage of the and leave the temporary string in a valid but unspecified state. At last the temporary string is released.

The different behavior cannot be observed in {cpp}.


a|
[source, cpp]
----
auto a = std::string(/* */);
auto b = std::move(a).substr(/* */);
----
| Value of `a` does not change
| As `a` is casted to anxvalue, the implementation of `.substr` can reuse the storage and leave `this` string in a valid but unspecified state.

The different behavior can be observed in {cpp}.

|===

Since {cpp}11 the {cpp} language supports move semantic.
All classes where it made sense where updated with move constructors and move assignment operators.
This made it possible to take advantage of rvalues and "steal" resources, thus avoiding, for example, unnecessary costly copies.

Some classes that came in later revisions of the language also take advantage of move semantic for member functions, like `std::optional::value` and `std::optional::value_or`.

In the case of `std::string::substr()`, it is possible to take advantage of move semantic to.

Consider following two code snippets:
//, found thanks to http://codesearch.isocpp.org[codesearch]:

[source, cpp]
----
// example 1
benchmark = std::string(argv[i]).substr(12);

// example 2
name_ = obs.stringValue().substr(0,32);
----

In the first example, `argv[1]` is copied in a temporary string, then `substr` creates a new object.
In this case one could use `string_view` to avoid the unnecessary copy, but changing already working code has a cost too.

In the second example, if `stringValue()` returns an `std::string` by value, the user of that API cannot use a `string_view` to avoid an unnecessary copy, like in the first case.


If `std::string` would have an overload for `substr() &&`, in both cases the standard library could avoid unnecessary work, and instead of copying the data "steal" it.

It is true that adding a new overload increases the already extremely high number of member functions of `std::string`.

On the other hand most users do not need to know it's existence to take advantage of the provided optimization.

For users aware of the overload, they can move a string in order to "steal" it's storage in a natural way:

[source, cpp]
----
std::string foo = ...;
std::string bar = std::move(foo).substr(...);
----


== Design Decisions

This is purely a library extension.


Currently `substr` is defined as


[source, cpp]
----
constexpr basic_string substr(size_type pos = 0, size_type n = npos) const;
----

This paper proposes to define following overloads

[source, cpp]
----
constexpr basic_string substr(size_type pos = 0, size_type n = npos) const &;
constexpr basic_string substr(size_type pos = 0, size_type n = npos) &&;
----


Other overloads (`constexpr basic_string substr(size_type pos = 0, size_type n = npos) const &&;` and `constexpr basic_string substr(size_type pos = 0, size_type n = npos) &;`) are not necessary.

Notice that the current proposal is a breaking change, as following snippet of code might work differently if this paper gets accepted:

[source, cpp]
----
std::string foo = ...;
std::string bar = std::move(foo).substr(...);
----


Until {cpp}20, `foo` wont change it's value, after this paper, the state of `foo` would be in a "valid but unspecified state".

While a breaking change is generally bad:

	* I do not think there exists code like `std::move(foo).substr(...)` in the wild
	* Even if such code exists, the intention of the author was very probably to tell the compiler that he is not interested in the value of `foo` anymore, as it is normally the case when moving a variable. In other words, with this proposal the user is getting what he asked for.


=== Note on the propagation of the allocator

`basic_string` is one of the allocator-container, which means that any memory resource used by this class need to be acquired and released to from the associated allocator instance. This imposes some limitation on the behavior of the proposed overload.. For example in:

[source, cpp]
----
std::pmr::string s1 = ....;
std::pmr::string s2 = std::move(s1).substr();
----

For `s2` to be able to steal memory from `s1`, we need to be sure that the allocators used by both objects are equal (`s1.get_allocator() == s2.get_allocator()`).
This is trivially achievable for the case of the for the allocators that are always equal (`std::allocator_traits<A>::is_always_equal::value` is true), including most common case of the stateless `std::allocator` and implementation can unconditionally steal any allocated memory in such situation.

Moreover, the proposed overload can still provide some optimization in case of the stateful allocators, where `s2.get_allocator()` (which is required to be default constructed) happens to be the same as allocator of the source `s1`.
In any remaining cases, behavior of this overload should follow existing const version, and as such it does not add any overhead.

This paper, recommends implementation to avoid additional memory allocation when possible (note if no-allocation would be performed, there is nothing to avoid), however it does not require so.
This leave it free for implementation to decide, if the optimization should be guarded by:

	* compile time check of `std::allocator_traits<A>::is_always_equal`
	* runtime comparison of allocators instance (addition comparison cost).


=== Overload with user supplied-allocator:

While writing the paper, we have noticed that specification of the `substr()` requires returned object to use default constructed allocator.
This means that invocation of this function is ill-formed for the `basic_string` instance with non-default constructing allocator, for example for invited `memory_pool_allocator<char>` that can be only constructed from reference to the pool, the following are ill-formed:

[source, cpp]
----
memory_pool pool = ...;
std::basic_string<char, std::char_traits<char>, memory_pool_allocator<char>> s1(memory_pool_allocator<char>(pool));
auto s2 = s1.substr();
----

This could be address by adding Allocator parameters to `substr()`` overload that accepts allocator to be used as parameter:

[source, cpp]
----
constexpr basic_string substr(size_type pos, const Allocator& alloc = Allocator()) const;
constexpr basic_string substr(size_type pos, size_type n, const Allocator& alloc = Allocator()) const;
----

We would like to see LEWG guidance on this change.

== Concerns on ABI stability

Changing `basic_string substr(std::size_t pos, std::size_t len) const;` into `basic_string substr(std::size_t pos, std::size_t len) const&;` and `basic_string substr(std::size_t pos, std::size_t len) &&;` (the first change is required by the core language rules), can affect the
mangling of the name, thus causing ABI break.

For a library it is possible to continue to define the old symbol, so that already existing code will continue to links and work without errors.
For example, it is possible to use asm to define the old mangled name as an alias for the new `const&` symbol.


This is not a novel technique, as it has been explained by ARG (the ABI Review group).
Similar breaks have already taken place for other papers, like https://wg21.link/p0408[P0408] and https://wg21.link/p0616[P0616].

== QOI ???

== Technical Specifications

Suggested wording (against http://open-std.org/jtc1/sc22/wg21/docs/papers/2021/n4892.pdf[N4892]):


Apply following changes to `[strings]`


[subs=+quotes]
----
constexpr basic_string substr(size_type pos = 0, size_type n = npos) const [underline]#&#;
[underline]#constexpr basic_string substr(size_type pos = 0, size_type n = npos) &&;#
----

Apply following changes to `[string.substr]`


[subs=+quotes]
----
constexpr basic_string substr(size_type pos = 0, size_type n = npos) const [underline]#&#;
[underline]#constexpr basic_string substr(size_type pos = 0, size_type n = npos) &&;#
----

_Effects_: Determines the effective length `rlen` of the string to copy as the smaller of `n` and `size() - pos`. +
_Returns_: `basic_­string(data()+pos, rlen)`. +
_Throws_: `out_­of_­range` if `pos > size()`. +
[underline]#_Recommended practice_: +
For the second overload, implementations should avoid unnecessary copies and allocations, if `r.get_allocator() == get_allocator()` is `true`, where `r` is value returned from the call. +
_Remarks_: `*this` is in valid but unspecified state after invocation of the second overload.#

== Acknowledgements

A big thank you to all those giving me feedback for this paper, especially Tomasz Kamiński for helping me writing it.
